<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Mr. LeGrasse in The Mysterious Maze</title>
		<style>
			body { margin: 0; cursor: none}
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
	<script src="three.js"></script>
	<script>

        /*GLOBAL CONSTANTS*/
        var WIDTH = window.innerWidth-3;
        var HEIGHT = window.innerHeight-3;
        var COLS = 15;
        var ROWS = 10;
        var STEP = 150;

        var WALLW = 190;
        var WALLH = 300;
        var WALLD = 40;

		var SEED = 80;

		var NULLVALUE = -1;
		var NULLCELL = new THREE.Vector4(NULLVALUE, NULLVALUE, NULLVALUE, NULLVALUE);

        var X = -COLS/2 * STEP;
        var Z = -ROWS/2 * STEP;

        var path = "textures/";

		var dist = 0;
		var distMax = (COLS*ROWS)/(COLS+ROWS);
		var start = new Array(0, 0);
		var end = new Array(0, 0);
		var s1, s2;


        /*Texture urls*/
        var URL1 = path + "wall2.jpg";
        var URL2 = path + "floor4.jpg";

        /*Basic Initialization*/
        var renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(0xdddddd);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.BasicShadowMap;
		document.body.appendChild(renderer.domElement);

		/*Event Listeners*/
		// document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		// document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		// document.addEventListener( 'mouseup', onDocumentMouseUp, false );

        /*Scene and Camera init*/
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 1, 10000);
        camera.position.set(0, 2000, 700);
        camera.lookAt(new THREE.Vector3(0,0,0));

		/*Personal Camera Init*/
		var personalCamera = new THREE.PerspectiveCamera(75, WIDTH/HEIGHT, 1, 10000);

		/*Lights*/
		lights = function(){
			// scene.add(new THREE.AmbientLight(0xffffff));
			var pointLight = new THREE.PointLight(0xdd8800, 50, 200, 2);
			pointLight.position.set(0, 0, 0);

			pointLight.castShadow = true;
			pointLight.shadow.camera.near = 1;
			pointLight.shadow.camera.far = 300;
			pointLight.shadow.bias = 0.01;

			s1.add(pointLight);
		}

		/*Function generating random numbers
		to adjust proportion of walls created
		@return 0,1*/
		generateRandom = function(){
            var rndSeed = THREE.Math.randInt(1,100);
            if(rndSeed > SEED){
                return 1;
            }else {
                return 0;
            }
        }

		/*Function generating vectors of random
		numbers, to build the walls in the
		matrix's cells.
		Calls generateRandom()*/
        generateVector4 = function(){
            return new THREE.Vector4(
                generateRandom(),
                generateRandom(),
                generateRandom(),
                generateRandom()
            );
        }

		/*Function generating the matrix.
		Calls generateVector4()
		@return matrix*/
        generateMatrix = function(){
            var matrix = new Array();
            for(i=0; i<ROWS; i++){
                matrix[i] = new Array();
                for(j=0; j<COLS; j++){
                    matrix[i][j] = generateVector4();
                }
            }
            return matrix;
        }

		/*Function generating the plane, the floor
		underlying the labyrinth.*/
        generatePlane = function(i, j){
            var planeGeom = new THREE.PlaneGeometry(STEP, STEP);
	        var floorText = new THREE.TextureLoader().load(URL2);
            var planeMat = new THREE.MeshLambertMaterial({color: 0x444455,
								map: floorText});
            var plane = new THREE.Mesh(planeGeom, planeMat);
			var ceiling = new THREE.Mesh(planeGeom, planeMat);
			plane.position.set( X + j * STEP,
								0,
								Z + i * STEP);
			plane.rotation.x = -Math.PI/2;
			plane.receiveShadow = true;
			scene.add(plane);
			ceiling.position.set( X + j * STEP,
								WALLH,
								Z + i * STEP);
			ceiling.rotation.x = Math.PI/2;
			ceiling.receiveShadow = true;
			scene.add(ceiling);
        }

		/*Function generating the walls, depending on
		the four random numbers contained in each matrix's cell*/
        generateWalls = function(vector, i, j){
            for(w=0; w<4; w++){
                if(vector.getComponent(w) == 1){
                    var wallGeom = new THREE.BoxGeometry(WALLW, WALLH, WALLD);
			        var wallText = new THREE.TextureLoader().load(URL1);
                    var wallMat = new THREE.MeshLambertMaterial({color: 0x666666,
									map: wallText});
                    var wall = new THREE.Mesh(wallGeom, wallMat);
                    wall.position.set(  X + (j - Math.sin(w * Math.PI/2)/2) * STEP,
                                        WALLH/2,
                                        Z + (i - Math.cos(w * Math.PI/2)/2) * STEP);
                    wall.rotation.set(  0,
                                        w * Math.PI/2,
                                        0);
					wall.receiveShadow = true;
					wall.castShadow = true;
                    scene.add(wall);
                }
            }
        }

		/*Function editing the vector of each matrix cell
		to build the labyrinth borders
		@return Vector4*/
		generateBorders = function(vector, i, j){
			if(i == 0){
				vector.setX(1);
			}else if (i == ROWS-1) {
					vector.setZ(1);
			}
			if(j == 0){
				vector.setY(1);
			}else if (j == COLS-1) {
				vector.setW(1);
			}
			return vector;
		}

		/*Generates the array of adjacent cells
		@return Vector4*/
		adjArray = function(matrix, i, j){
			var north, west, south, east;
			if(i == 0){
				north = NULLCELL;
				south = matrix[i+1][j];
			}else if (i == ROWS-1) {
					north = matrix[i-1][j];
					south = NULLCELL;
			}else {
				north = matrix[i-1][j];
				south = matrix[i+1][j];
			}
			if(j == 0){
				west = NULLCELL;
				east = matrix[i][j+1];
			}else if (j == COLS-1) {
				west = matrix[i][j-1];
				east = NULLCELL;
			}else {
				west = matrix[i][j-1];
				east = matrix[i][j+1];
			}
			return new THREE.Vector4(north, west, south, east);
		}

		/*Checks if current cell is completely enclosed by walls
		@return boolean*/
		checkClosed = function(vectorCurrentCell, vectorAdjCells){
			var northCell = vectorAdjCells.getComponent(0);
			var westCell = vectorAdjCells.getComponent(1);
			var southCell = vectorAdjCells.getComponent(2);
			var eastCell = vectorAdjCells.getComponent(3);
			if(
				(
					vectorCurrentCell.getComponent(0) === 1 ||
					northCell.getComponent(2) === 1
				) &&

				(
					vectorCurrentCell.getComponent(1) === 1 ||
					westCell.getComponent(3) === 1
				) &&

				(
					vectorCurrentCell.getComponent(2) === 1 ||
					southCell.getComponent(0) === 1
				) &&

				(
					vectorCurrentCell.getComponent(0) === 1 ||
					eastCell.getComponent(3) === 1
				)
			) {
					return true;
				}else {
					return false;
				}
		}

		/*Eventually deletes walls closing off a 1x1 tile
		@return Array()*/
		thouShaltPass = function(vectorCurrentCell, vectorCheckingCell, k){
			if(k == 0){
				vectorCurrentCell.setComponent(0, 0);
				vectorCheckingCell.setComponent(2, 0);
			}else if (k == 1) {
				vectorCurrentCell.setComponent(1, 0);
				vectorCheckingCell.setComponent(3, 0);
			}else if (k == 2) {
				vectorCurrentCell.setComponent(2, 0);
				vectorCheckingCell.setComponent(0, 0);
			}else {
				vectorCurrentCell.setComponent(3, 0);
				vectorCheckingCell.setComponent(1, 0);
			}
			return new Array(vectorCurrentCell, vectorCheckingCell);
		}

		/*Function eliminating 1x1 tiles encased by walls
		@return matrix*/
		noSingletons = function(matrix){
			for(i=0; i<ROWS; i++){
                for(j=0; j<COLS; j++){
					var current = matrix[i][j];
                    var adjacentCells = adjArray(matrix, i, j);
					while(checkClosed(current, adjacentCells)){
						for(k=0; k<4; k++){
							var checking = adjacentCells.getComponent(k);
							var checkValue = checking.getComponent(0);
							if(checkValue !== NULLVALUE){
								var returned = thouShaltPass(current, checking, k);
								matrix[i][j] = returned[0];
								if(k == 0){
									matrix[i-1][j] = returned[1];
								}else if (k == 1) {
									matrix[i][j-1] = returned[1];
								}else if (k == 2) {
									matrix[i+1][j] = returned[1];
								}else{
									matrix[i][j+1] = returned[1];
								}
							}
						}
					}
                }
            }
			return matrix;
		}

		/*Function tweaking the wall generation to
		generate a better labyrinth structure.
		Calls generateBorders()
		@return matrix*/
		adjustMatrix = function(matrix){
			for(i=0; i<ROWS; i++){
                for(j=0; j<COLS; j++){
                    matrix[i][j] = generateBorders(matrix[i][j], i, j);
                }
            }
			matrix = noSingletons(matrix);
			return matrix;
        }

		/*Checks if there is free passage between two adjacent cells*/
		canPass = function(matrix, dir){
			var i = end[1];
			var j = end[0];
			switch(dir){
				case 0:
					if(i>0){
						if(matrix[i][j].getComponent(0) == 1 ||
							matrix[i-1][j].getComponent(2) == 1){
							return false;
						}else{
							return true;
						}
					}else{
						return false;
					}
					break;
				case 1:
					if(j>0){
						if(matrix[i][j].getComponent(1) == 1 ||
							matrix[i][j-1].getComponent(3) == 1){
							return false;
						}else{
							return true;
						}
					}else{
						return false;
					}
					break;
				case 2:
					if(i<ROWS){
						if(matrix[i][j].getComponent(2) == 1 ||
							matrix[i+1][j].getComponent(0) == 1){
							return false;
						}else{
							return true;
						}
					}else{

					}	return false;
					break;
				case 3:
					if(j<COLS){
						if(matrix[i][j].getComponent(3) == 1 ||
							matrix[i][j+1].getComponent(1) == 1){
							return false;
						}else{
							return true;
						}
					}else{
						return false;
					}
					break;
				default:
					return false;
			}
		}

		/*Calculates the distance between start and end*/
		calculateDistance = function(){
			var a = start[0];
			var b = start[1];
			var c = end[0];
			var d = end[1];
			colDist = Math.abs(a-c);
			rowDist = Math.abs(b-d);
			colDistSqr = Math.pow(colDist, 2);
			rowDistSqr = Math.pow(rowDist, 2);
			sum = colDistSqr + rowDistSqr;
			dist = Math.sqrt(sum);
		}

		/*Recursively builds a path from start to end of distMax length*/
		findPath = function(matrix){
			var dir = THREE.Math.randInt(0, 3);
			var incremented = false;
			while(!incremented){
				if(dir == 0 && end[1]>0){
					if(canPass(matrix, dir)){
						end[1] -= 1;
						incremented = true;
					}
				}else if (dir == 1 && end[0]>0){
					if(canPass(matrix, dir)){
						end[0] -= 1;
						incremented = true;
					}
				}else if (dir == 2 && end[1]<ROWS){
					if(canPass(matrix, dir)){
						end[1] += 1;
						incremented = true;
					}
				}else if (dir == 3 && end[0]<COLS){
					if(canPass(matrix, dir)){
						end[0] +=1;
						incremented = true;
					}
				}
				dir = THREE.Math.randInt(0, 3);
			}
			calculateDistance();
			if(dist < distMax){
				findPath(matrix);
			}
		}

		/*Randomly generates the starting and ending points*/
		generateStartEnd = function(matrix){
			while(dist < distMax){
				var n = THREE.Math.randInt(0, COLS-1);
				var m = THREE.Math.randInt(0, ROWS-1);
				start[0] = n;
				start[1] = m;
				end[0] = start[0];
				end[1] = start[1];
				findPath(matrix);
				calculateDistance();
			}
		}

		/**/
		initGame = function(indexVector){
			var sg = new THREE.SphereGeometry(20, 70, 70);
			var sm1 = new THREE.MeshPhongMaterial({color: 0x00b600, shininess: 0});
			var sm2 = new THREE.MeshPhongMaterial({color: 0xb60000, shininess: 0,
			emissive: 0xb60000, emissiveIntensity: 4});
			s1 = new THREE.Mesh(sg, sm1);
			s2 = new THREE.Mesh(sg, sm2);
			s1.position.set(X + start[0] * STEP,
							100,
							Z + start[1] * STEP);
			s2.position.set(X + end[0] * STEP,
							50,
							Z + end[1] * STEP);
			scene.add(s1);
			scene.add(s2);
		}


		/*Main function, generating the labyrinth and
		causing direct or indirect invocation of all other
		generating functions*/
        generateLabyrinth = function(){
            var matrix = adjustMatrix(generateMatrix());
			var startEnd = generateStartEnd(matrix);
            for(i=0; i<ROWS; i++){
                for(j=0; j<COLS; j++){
                    generatePlane(i, j);
                    generateWalls(matrix[i][j], i, j);
                }
            }
			initGame(startEnd);
        }

		/*STUB*/
		cameraUpdate = function(){
			var spherex = s1.position.x;
			var spherey = s1.position.y;
			var spherez = s1.position.z;
			personalCamera.position.set(spherex-50, spherey+60, spherez);
		}

		/*Rendering function*/
		render = function(){
			requestAnimationFrame(render);
			cameraUpdate();
			renderer.render(scene, camera);
			// renderer.render(scene, personalCamera);
		}

		generateLabyrinth();
		lights();
		render();

	</script>
	</body>
</html>
