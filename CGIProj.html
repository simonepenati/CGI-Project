<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Mr. LeGrasse in The Mysterious Maze</title>
		<style>
			body { margin: 0; cursor: none}
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
	<script src="three.js"></script>
	<script>

        /*GLOBAL CONSTANTS*/
        var WIDTH = window.innerWidth-3;
        var HEIGHT = window.innerHeight-3;
        var COLS = 15;
        var ROWS = 10;
        var STEP = 200;

        var WALLW = 230;
        var WALLH = 400;
        var WALLD = 30;

		var SEED = 80;
		var VIEWDIST = 400;
		var BOUND = 20;

		var NULLVALUE = -1;
		var NULLCELL = new THREE.Vector4(NULLVALUE, NULLVALUE, NULLVALUE, NULLVALUE);

        var X = -COLS/2 * STEP;
        var Z = -ROWS/2 * STEP;
		var speed = 1;

		var lon = 0, lat = 0,
		theta = 0, phi = 0,
		isUserInteractingMouse = false,
		pointerX = 0, pointerY = 0,
		pointerLon = 0, pointerLat = 0;
		var rho = 10;

        var path = "textures/";

		var dist = 0;
		var distMax = (COLS*ROWS)/(COLS+ROWS);
		var start = new Array(0, 0);
		var end = new Array(0, 0);
		var character;
		var s2;
		var rays = [];
		var obstacles = [];
		var matrix;

		var axisX = new THREE.Vector3(1, 0, 0);
		var axisY = new THREE.Vector3(0, 1, 0);
		var axisZ = new THREE.Vector3(0, 0, 1);

		var axisEast = new THREE.Vector3(0, 0, 0);
		var axisSouth = new THREE.Vector3(0, 0, 0);
		var axisWest = new THREE.Vector3(0, 0, 0);
		var axisNorth = new THREE.Vector3(0, 0, 0);
		var axisNorthEast = new THREE.Vector3(0, 0, 0);
		var axisNorthWest = new THREE.Vector3(0, 0, 0);
		var axisSouthEast = new THREE.Vector3(0, 0, 0);
		var axisSouthWest = new THREE.Vector3(0, 0, 0);

		var forwards = new THREE.Vector3(0, 0, 0);
		var carrot = new THREE.Vector3(0, 0, 0);
		var canGo = true;

        /*Texture urls*/
        var URL1 = path + "wall2.jpg";
        var URL2 = path + "floor4.jpg";

        /*Basic Initialization*/
        var renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(0x000000);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.BasicShadowMap;
		document.body.appendChild(renderer.domElement);

		/*Event Listeners*/
		document.addEventListener("mousedown", onMouseDown, false);
		document.addEventListener("mousemove", onMouseMove, false);
		document.addEventListener("mouseup", onMouseUp, false);
		document.addEventListener("mousewheel", onMouseWheel, false);
		document.addEventListener("keydown", onKeyDownW, false);
		document.addEventListener("keydown", onKeyDownA, false);
		document.addEventListener("keydown", onKeyDownD, false);
		document.addEventListener("keypressed", onKeyPressedW, false);
		document.addEventListener("keypressed", onKeyPressedA, false);
		document.addEventListener("keypressed", onKeyPressedD, false);
		document.addEventListener("keyup", onKeyUp, false);

        /*Scene and Fog init*/
        var scene = new THREE.Scene();
		var fog = new THREE.Fog(0x000005, 370, 10000);
		scene.add(fog);

		/*Standard Camera Init*/
        var camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 1, 10000);
        camera.position.set(0, 2500, 900);
        camera.lookAt(new THREE.Vector3(0,0,0));

		/*Personal Camera Init*/
		var personalCamera = new THREE.PerspectiveCamera(75, WIDTH/HEIGHT, 1, 1000);

		/*Lights*/
		lights = function(){
			var pointLight = new THREE.PointLight(0xdd8800, 10, 350, 2);
			pointLight.position.set(0, 0, 0);

			pointLight.castShadow = true;
			pointLight.shadow.camera.near = 1;
			pointLight.shadow.camera.far = 400;
			pointLight.shadow.bias = 0.01;

			character.add(pointLight);
		}

		/*Gets Mouse position at click*/
		function onMouseDown(event){
	   				event.preventDefault();
	   				isUserInteractingMouse = true;
	   				pointerX = event.clientX;
	 				pointerY = event.clientY;
	   				pointerLon = lon;
	 				pointerLat = lat;
		  	}

		/*Updates movement when mouse clicked and moved*/
		function onMouseMove(event){
			if (isUserInteractingMouse === true) {
				lon = (pointerX - event.clientX) * 0.5 + pointerLon;
				lat = (event.clientY - pointerY) * 0.5 + pointerLat;
				if(lon > 360){
					lon -= 360;
				}
			}
		}

		/*Recognizes that user is no longer pressing mouse button*/
		function onMouseUp(event) {
			isUserInteractingMouse = false;
		}

		/*Moves the camera farther and closer to the character*/
		function onMouseWheel(event) {
			rho -= event.wheelDeltaY * 0.01;
		}

		/*Handles movement of the character and sprint*/
		function onKeyDownW(event){
			event.preventDefault();
			if(event.char === "w"){
				if(canGo){
					character.translateOnAxis(axisZ, -STEP/10 * 0.3 * speed);
				}
			}
		}
		function onKeyDownA(event){
			event.preventDefault();
			if(event.char === "a"){
				lon -= 5;
				if(lon > 360){
					lon -= 360;
				}
			}
		}
		function onKeyDownD(event){
			event.preventDefault();
			if(event.char === "d"){
				lon += 5;
				if(lon > 360){
					lon -= 360;
				}
			}
		}

		/*Handles continued movement of character and sprint*/
		function onKeyPressedW(event){
			event.preventDefault();
			if(event.char === "w"){
				if(canGo){
					character.translateOnAxis(axisZ, -STEP/10 * 0.3 * speed);
				}
			}
		}
		function onKeyPressedA(event){
			event.preventDefault();
			if(event.char === "a"){
				lon -= 5;
				if(lon > 360){
					lon -= 360;
				}
			}
		}
		function onKeyPressedD(event){
			event.preventDefault();
			if(event.char === "d"){
				lon += 5;
				if(lon > 360){
					lon -= 360;
				}
			}
		}

		function onKeyUp(event){}

		/*Function generating random numbers
		to adjust proportion of walls created
		@return 0,1*/
		generateRandom = function(){
            var rndSeed = THREE.Math.randInt(1,100);
            if(rndSeed > SEED){
                return 1;
            }else {
                return 0;
            }
        }

		/*Function generating vectors of random
		numbers, to build the walls in the
		matrix's cells.
		Calls generateRandom()*/
        generateVector4 = function(){
            return new THREE.Vector4(
                generateRandom(),
                generateRandom(),
                generateRandom(),
                generateRandom()
            );
        }

		/*Function generating the matrix.
		Calls generateVector4()
		@return matrix*/
        generateMatrix = function(){
            var matrix = new Array();
            for(i=0; i<ROWS; i++){
                matrix[i] = new Array();
                for(j=0; j<COLS; j++){
                    matrix[i][j] = generateVector4();
                }
            }
            return matrix;
        }

		/*Function generating the plane, the floor
		underlying the labyrinth.*/
        generatePlane = function(i, j){
            var planeGeom = new THREE.PlaneGeometry(STEP, STEP);
	        var floorText = new THREE.TextureLoader().load(URL2);
            var planeMat = new THREE.MeshLambertMaterial({color: 0x444455,
								map: floorText});
            var plane = new THREE.Mesh(planeGeom, planeMat);
			var ceiling = new THREE.Mesh(planeGeom, planeMat);
			plane.position.set( X + j * STEP,
								0,
								Z + i * STEP);
			plane.rotation.x = -Math.PI/2;
			plane.receiveShadow = true;
			obstacles = obstacles.concat(plane);
			ceiling.position.set( X + j * STEP,
								WALLH,
								Z + i * STEP);
			ceiling.rotation.x = Math.PI/2;
			ceiling.receiveShadow = true;
			obstacles = obstacles.concat(ceiling);
        }

		/*Function generating the walls, depending on
		the four random numbers contained in each matrix's cell*/
        generateWalls = function(i, j){
			var vector = matrix[i][j];
            for(w=0; w<4; w++){
                if(vector.getComponent(w) == 1){
                    var wallGeom = new THREE.BoxGeometry(WALLW, WALLH, WALLD, 10, 10, 10);
			        var wallText = new THREE.TextureLoader().load(URL1);
                    var wallMat = new THREE.MeshLambertMaterial({color: 0x666666,
									map: wallText});
                    var wall = new THREE.Mesh(wallGeom, wallMat);
                    wall.position.set(  X + (j - Math.sin(w * Math.PI/2)/2) * STEP,
                                        WALLH/2,
                                        Z + (i - Math.cos(w * Math.PI/2)/2) * STEP);
                    wall.rotation.set(  0,
                                        w * Math.PI/2,
                                        0);
					wall.receiveShadow = true;
					wall.castShadow = true;
					obstacles = obstacles.concat(wall);
                }
            }
        }

		/*Function editing the vector of each matrix cell
		to build the labyrinth borders
		@return Vector4*/
		generateBorders = function(vector, i, j){
			if(i == 0){
				vector.setX(1);
			}else if (i == ROWS-1) {
					vector.setZ(1);
			}
			if(j == 0){
				vector.setY(1);
			}else if (j == COLS-1) {
				vector.setW(1);
			}
			return vector;
		}

		/*Generates the array of adjacent cells
		@return Vector4*/
		adjArray = function(matrix, i, j){
			var north, west, south, east;
			if(i == 0){
				north = NULLCELL;
				south = matrix[i+1][j];
			}else if (i == ROWS-1) {
					north = matrix[i-1][j];
					south = NULLCELL;
			}else {
				north = matrix[i-1][j];
				south = matrix[i+1][j];
			}
			if(j == 0){
				west = NULLCELL;
				east = matrix[i][j+1];
			}else if (j == COLS-1) {
				west = matrix[i][j-1];
				east = NULLCELL;
			}else {
				west = matrix[i][j-1];
				east = matrix[i][j+1];
			}
			return new THREE.Vector4(north, west, south, east);
		}

		/*Checks if current cell is completely enclosed by walls
		@return boolean*/
		checkClosed = function(vectorCurrentCell, vectorAdjCells){
			var northCell = vectorAdjCells.getComponent(0);
			var westCell = vectorAdjCells.getComponent(1);
			var southCell = vectorAdjCells.getComponent(2);
			var eastCell = vectorAdjCells.getComponent(3);
			if(
				(
					vectorCurrentCell.getComponent(0) === 1 ||
					northCell.getComponent(2) === 1
				) &&

				(
					vectorCurrentCell.getComponent(1) === 1 ||
					westCell.getComponent(3) === 1
				) &&

				(
					vectorCurrentCell.getComponent(2) === 1 ||
					southCell.getComponent(0) === 1
				) &&

				(
					vectorCurrentCell.getComponent(0) === 1 ||
					eastCell.getComponent(3) === 1
				)
			) {
					return true;
				}else {
					return false;
				}
		}

		/*Eventually deletes walls closing off a 1x1 tile
		@return Array()*/
		thouShaltPass = function(vectorCurrentCell, vectorCheckingCell, k){
			if(k == 0){
				vectorCurrentCell.setComponent(0, 0);
				vectorCheckingCell.setComponent(2, 0);
			}else if (k == 1) {
				vectorCurrentCell.setComponent(1, 0);
				vectorCheckingCell.setComponent(3, 0);
			}else if (k == 2) {
				vectorCurrentCell.setComponent(2, 0);
				vectorCheckingCell.setComponent(0, 0);
			}else {
				vectorCurrentCell.setComponent(3, 0);
				vectorCheckingCell.setComponent(1, 0);
			}
			return new Array(vectorCurrentCell, vectorCheckingCell);
		}

		/*Function eliminating 1x1 tiles encased by walls
		@return matrix*/
		noSingletons = function(matrix){
			for(i=0; i<ROWS; i++){
                for(j=0; j<COLS; j++){
					var current = matrix[i][j];
                    var adjacentCells = adjArray(matrix, i, j);
					while(checkClosed(current, adjacentCells)){
						for(k=0; k<4; k++){
							var checking = adjacentCells.getComponent(k);
							var checkValue = checking.getComponent(0);
							if(checkValue !== NULLVALUE){
								var returned = thouShaltPass(current, checking, k);
								matrix[i][j] = returned[0];
								if(k == 0){
									matrix[i-1][j] = returned[1];
								}else if (k == 1) {
									matrix[i][j-1] = returned[1];
								}else if (k == 2) {
									matrix[i+1][j] = returned[1];
								}else{
									matrix[i][j+1] = returned[1];
								}
							}
						}
					}
                }
            }
			return matrix;
		}

		/*Function tweaking the wall generation to
		generate a better labyrinth structure.
		Calls generateBorders()
		@return matrix*/
		adjustMatrix = function(matrix){
			for(i=0; i<ROWS; i++){
                for(j=0; j<COLS; j++){
                    matrix[i][j] = generateBorders(matrix[i][j], i, j);
                }
            }
			matrix = noSingletons(matrix);
			return matrix;
        }

		/*Checks if there is free passage between two adjacent cells*/
		canPass = function(matrix, dir){
			var i = end[1];
			var j = end[0];
			switch(dir){
				case 0:
					if(i>0){
						if(matrix[i][j].getComponent(0) == 1 ||
							matrix[i-1][j].getComponent(2) == 1){
							return false;
						}else{
							return true;
						}
					}else{
						return false;
					}
					break;
				case 1:
					if(j>0){
						if(matrix[i][j].getComponent(1) == 1 ||
							matrix[i][j-1].getComponent(3) == 1){
							return false;
						}else{
							return true;
						}
					}else{
						return false;
					}
					break;
				case 2:
					if(i<ROWS){
						if(matrix[i][j].getComponent(2) == 1 ||
							matrix[i+1][j].getComponent(0) == 1){
							return false;
						}else{
							return true;
						}
					}else{

					}	return false;
					break;
				case 3:
					if(j<COLS){
						if(matrix[i][j].getComponent(3) == 1 ||
							matrix[i][j+1].getComponent(1) == 1){
							return false;
						}else{
							return true;
						}
					}else{
						return false;
					}
					break;
				default:
					return false;
			}
		}

		/*Calculates the distance between start and end*/
		calculateDistance = function(a, b, c, d){
			colDist = Math.abs(a-c);
			rowDist = Math.abs(b-d);
			colDistSqr = Math.pow(colDist, 2);
			rowDistSqr = Math.pow(rowDist, 2);
			sum = colDistSqr + rowDistSqr;
			return Math.sqrt(sum);
		}

		/*Recursively builds a path from start to end of distMax length*/
		findPath = function(matrix){
			var dir = THREE.Math.randInt(0, 3);
			var incremented = false;
			while(!incremented){
				if(dir == 0 && end[1]>0){
					if(canPass(matrix, dir)){
						end[1] -= 1;
						incremented = true;
					}
				}else if (dir == 1 && end[0]>0){
					if(canPass(matrix, dir)){
						end[0] -= 1;
						incremented = true;
					}
				}else if (dir == 2 && end[1]<ROWS){
					if(canPass(matrix, dir)){
						end[1] += 1;
						incremented = true;
					}
				}else if (dir == 3 && end[0]<COLS){
					if(canPass(matrix, dir)){
						end[0] +=1;
						incremented = true;
					}
				}
				dir = THREE.Math.randInt(0, 3);
			}
			dist = calculateDistance(start[0], start[1], end[0], end[1]);
			if(dist < distMax){
				findPath(matrix);
			}
		}

		/*Randomly generates the starting and ending points*/
		generateStartEnd = function(){
			while(dist < distMax){
				var n = THREE.Math.randInt(0, COLS-1);
				var m = THREE.Math.randInt(0, ROWS-1);
				start[0] = n;
				start[1] = m;
				end[0] = start[0];
				end[1] = start[1];
				findPath(matrix);
				dist = calculateDistance(start[0], start[1], end[0], end[1]);
			}
		}

		/*Generates raycasters between character and walls*/
		raycast = function(){
			rays.length = 0;
			var origin = new THREE.Vector3(character.position.x,
										   character.position.y,
										   character.position.z);
			axisEast = new THREE.Vector3(origin.x + 1, origin.y, origin.z);
			axisEast.normalize();
			axisSouth = new THREE.Vector3(origin.x, origin.y, origin.z + 1);
			axisSouth.normalize();
			axisWest = new THREE.Vector3(origin.x - 1, origin.y, origin.z);
			axisWest.normalize();
			axisNorth = new THREE.Vector3(origin.x, origin.y, origin.z - 1);
			axisNorth.normalize();
			axisNorthEast = new THREE.Vector3(origin.x + 1, origin.y, origin.z - 1);
			axisNorthEast.normalize();
			axisNorthWest = new THREE.Vector3(origin.x - 1, origin.y, origin.z - 1);
			axisNorthWest.normalize();
			axisSouthEast = new THREE.Vector3(origin.x + 1, origin.y, origin.z + 1);
			axisSouthEast.normalize();
			axisSouthWest = new THREE.Vector3(origin.x - 1, origin.y, origin.z + 1);
			axisSouthWest.normalize();

			rays = rays.concat(new THREE.Raycaster(origin, axisEast, 0, 3 * BOUND));
			rays = rays.concat(new THREE.Raycaster(origin, axisSouth, 0, 3 * BOUND));
			rays = rays.concat(new THREE.Raycaster(origin, axisWest, 0, 3 * BOUND));
			rays = rays.concat(new THREE.Raycaster(origin, axisNorth, 0, 3 * BOUND));
			rays = rays.concat(new THREE.Raycaster(origin, axisNorthEast, 0, 3 * BOUND));
			rays = rays.concat(new THREE.Raycaster(origin, axisNorthWest, 0, 3 * BOUND));
			rays = rays.concat(new THREE.Raycaster(origin, axisSouthEast, 0, 3 * BOUND));
			rays = rays.concat(new THREE.Raycaster(origin, axisSouthWest, 0, 3 * BOUND));
		}

		/*Checks collisions*/
		collideCheck = function(){
			var intersections = [];
			for(i=0; i<rays.length; i++){
				intersections = intersections.concat(rays[i].intersectObject(scene, true));
			}
			for(t=0; t<intersections.length; t++){
				if(intersections[t].distance <= BOUND){
					var collisionPoint = intersections[t].point;
					var XDiff = collisionPoint.x - character.position.x;
					var YDiff = collisionPoint.y - character.position.y
					var ZDiff = collisionPoint.z - character.position.z
					var collisionVector = new THREE.Vector3(XDiff, YDiff, ZDiff);
					wayMod = calculateDistance(forwards.x, forwards.z, 0, 0);
					colMod = calculateDistance(collisionPoint.x, collisionPoint.z,
											   character.position.x, character.position.z);
					wayColMod = calculateDistance(carrot.x, carrot.z,
												  collisionPoint.x, collisionPoint.z);
					cosAngle = (Math.pow(wayMod, 2) + Math.pow(colMod, 2) -
								Math.pow(wayColMod, 2))/(2 * wayMod * colMod);
					// sinAngle =
					if(cosAngle > 0){
						canGo = false;
					}else {
						canGo = true;
					}
				}
			}
		}

		/*Draws visible portions of the labyrinth each frame*/
		draw = function(){
			var charX = character.position.x;
			var charZ = character.position.z;
			for(n=0; n<obstacles.length; n++){
				var obs = obstacles[n];
				var obsX = obs.position.x;
				var obsZ = obs.position.z;
				scene.remove(obs);
				if(calculateDistance(charX, charZ, obsX, obsZ) < VIEWDIST){
					scene.add(obs);
				}
			}
		}

		/*Starts the game*/
		initGame = function(){
			var sg = new THREE.SphereGeometry(BOUND, 30, 30);
			var lol = new THREE.TextureLoader().load(URL1);
			var sm1 = new THREE.MeshPhongMaterial({color: 0x00b600, shininess: 0,
			emissive: 0x00b600, emissiveIntensity: 2});
			var sm2 = new THREE.MeshPhongMaterial({color: 0xb60000, shininess: 0,
			emissive: 0xb60000, emissiveIntensity: 4});
			character = new THREE.Mesh(sg, sm1);
			s2 = new THREE.Mesh(sg, sm2);
			character.position.set(X + start[0] * STEP,
							170,
							Z + start[1] * STEP);
			s2.position.set(X + end[0] * STEP,
							50,
							Z + end[1] * STEP);
			obstacles = obstacles.concat(s2);
			draw();
			scene.add(character);
			personalCamera.position.set(character.position.x + 50,
			 							character.position.y,
										character.position.z);
		}

		/*Main function, generating the labyrinth and
		causing direct or indirect invocation of all other
		generating functions*/
        generateLabyrinth = function(){
            matrix = adjustMatrix(generateMatrix());
			generateStartEnd();
			for(i=0; i<ROWS; i++){
                for(j=0; j<COLS; j++){
                    generatePlane(i, j);
                    generateWalls(i, j);
                }
            }
			initGame();
        }

		/*Updates the camera position relatively to the character
		and the character facing direction*/
		cameraUpdate = function(){
			var spherex = character.position.x;
			var spherey = character.position.y;
			var spherez = character.position.z;
			var currCamX = personalCamera.position.x;
			var currCamY = personalCamera.position.y;
			var currCamZ = personalCamera.position.z;
			var dX = spherex - currCamX;
			var dY = spherey - currCamY;
			var dZ = spherez - currCamZ;
			var lerp = 1/rho;

			personalCamera.position.x += dX * lerp;
			personalCamera.position.y += dY * lerp;
			personalCamera.position.z += dZ * lerp;

			lat = Math.max(-89, Math.min(89, lat));
			rho = Math.max(1, Math.min(10, rho));
			theta = THREE.Math.degToRad(90 - lat);
			phi = THREE.Math.degToRad(lon);
			var x1 = rho * Math.sin(theta) * Math.cos(phi);
			var y1 = rho * Math.cos(theta);
			var z1 = rho * Math.sin(theta) * Math.sin(phi);

			personalCamera.position.x += x1;
			personalCamera.position.y += y1;
			personalCamera.position.z += z1;

			var target = new THREE.Vector3(spherex, spherey, spherez);
			forwards.set(x1, 0 , z1);
			carrot = forwards.addVectors(target, forwards);
			personalCamera.lookAt(target);
			character.lookAt(carrot);
			draw();
		}

		/*Rendering function*/
		animate = function(){
			requestAnimationFrame(animate);
			raycast();
			collideCheck();
			cameraUpdate();
			// renderer.render(scene, camera);
			renderer.render(scene, personalCamera);
		}

		generateLabyrinth();
		lights();
		animate();

	</script>
	</body>
</html>
