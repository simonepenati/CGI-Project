<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>CGI PROJ</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
	<script src="three.js"></script>
	<script>

        /*GLOBAL CONSTANTS*/
        var WIDTH = window.innerWidth-3;
        var HEIGHT = window.innerHeight-3;
        var COLS = 10;
        var ROWS = 10;
        var STEP = 100;
        var WALLW = 120;
        var WALLH = 100;
        var WALLD = 20;
        var X = -COLS/2 * STEP;
        var Z = -ROWS/2 * STEP;
        var path = "textures/"

        /*Texture urls*/
        var URL1 = path + "wall2.jpg";
        var URL2 = path + "floor2.jpg";

        /*Basic Initialization*/
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(0xdddddd);
        document.body.appendChild(renderer.domElement);

        /*Scene and Camera init*/
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 1, 10000);
        camera.position.set(0, 1500, 400);
        camera.lookAt(new THREE.Vector3(0,0,0));

		/*Function generating random numbers
		to adjust proportion of walls created*/
		generateRandom = function(){
            var rndSeed = THREE.Math.randInt(1,100);
            if(rndSeed>75){
                return 1;
            }else {
                return 0;
            }
        }

		/*Function generating vectors of random
		numbers, to build the walls in the
		matrix's cells.
		Calls generateRandom()*/
        generateVector4 = function(){
            return new THREE.Vector4(
                generateRandom(),
                generateRandom(),
                generateRandom(),
                generateRandom()
            );
        }

		/*Function generating the matrix.
		Calls generateVector4()*/
        generateMatrix = function(){
            var matrix = new Array();
            for(i=0; i<ROWS; i++){
                matrix[i] = new Array();
                for(j=0; j<COLS; j++){
                    matrix[i][j] = generateVector4();
                }
            }
            return matrix;
        }

		/*Function generating the plane, the floor
		underlying the labyrinth.*/
        generatePlane = function(i, j){
            var planeGeom = new THREE.PlaneGeometry(STEP, STEP);
	        var floorText = new THREE.TextureLoader().load(URL2);
            var planeMat = new THREE.MeshBasicMaterial({map: floorText});
            var plane = new THREE.Mesh(planeGeom, planeMat);
			plane.position.set( X + j * STEP,
								0,
								Z + i * STEP);
			plane.rotation.x = -Math.PI/2;
			scene.add(plane);
        }

		/*Function generating the walls, depending on
		the four random numbers contained in each matrix's cell*/
        generateWalls = function(vector, i, j){
            for(w=0; w<4; w++){
                if(vector.getComponent(w) == 1){
                    var wallGeom = new THREE.BoxGeometry(WALLW, WALLH, WALLD);
			        var wallText = new THREE.TextureLoader().load(URL1);
                    var wallMat = new THREE.MeshBasicMaterial({map: wallText});
                    var wall = new THREE.Mesh(wallGeom, wallMat);
                    wall.position.set(  X + (j - Math.sin(w * Math.PI/2)/2) * STEP,
                                        STEP/2,
                                        Z + (i - Math.cos(w * Math.PI/2)/2) * STEP);
                    wall.rotation.set(  0,
                                        w * Math.PI/2,
                                        0);
                    scene.add(wall);
                }
            }
        }

		/*Function editing the vector of each matrix cell
		to build the labyrinth borders*/
		generateBorders = function(vector, i, j){
			if(i == 0){
				vector.setX(1);
			}else if (i == ROWS-1) {
					vector.setZ(1);
			}
			if(j == 0){
				vector.setY(1);
			}else if (j == COLS-1) {
				vector.setW(1);
			}
			return vector;
		}

		/*Function tweaking the wall generation to
		generate a better labyrinth structure.
		Calls generateBorders()*/
		adjustMatrix = function(matrix){
			for(i=0; i<ROWS; i++){
                for(j=0; j<COLS; j++){
                    matrix[i][j] = generateBorders(matrix[i][j], i, j);
                }
            }
			return matrix;
        }

		/*Main function, generating the labyrinth and
		causing direct or indirect invocation of all other
		generating functions*/
        generateLabyrinth = function(){
            var matrix = adjustMatrix(generateMatrix());
            for(i=0; i<ROWS; i++){
                for(j=0; j<COLS; j++){
                    generatePlane(i, j);
                    generateWalls(matrix[i][j], i, j);
                }
            }
        }

        generateLabyrinth();

        scene.add(new THREE.AmbientLight(0xffffff));
		render = function(){
			requestAnimationFrame(render);
			renderer.render(scene, camera);
		}
		render();

	</script>
	</body>
</html>
